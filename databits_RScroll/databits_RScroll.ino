#include "FastLED.h"
#include <avr/pgmspace.h>
#include <NewPing.h>
#include "button.h"

#define DEBUG 0
#define NUM_LEDS 256
#define MIN_ASCII 47
#define MAX_ASCII 90
#define CHAR_WIDTH 16 /* The width of the array/data */
#define CHAR_REAL_WIDTH 12 /* The width of the pixels to display */

#define INIT_BRIGHT 60

//Time for conecube to display, msec
#define CONE_CUBE_DISPLAY_TIME 3000

//LED Panel output
#define DATA_PIN 11

//Buttons
#define COLOR_BUTTON 4
#define CUBE_BUTTON 7
#define CONE_BUTTON 8
#define DISTANCE_BUTTON 9

//Analog Pot
#define POT_PIN A3

//Ultrasonic sensor
#define ECHO_PIN 10
#define MAX_DISTANCE 200  /* cm, about 6 ft */
#define TARGET_DISTANCE 24  /* Inches for "exact" */
#define NUM_RETRIES 7 /* Check distance this many times to get good reading */
NewPing sonar(ECHO_PIN, ECHO_PIN, MAX_DISTANCE);

Button colorBtn;
Button cubeBtn;
Button coneBtn;
Button distanceBtn;

//Set up LED array
CRGB leds[NUM_LEDS];

/**
  * This is run at initialization only
  */
void setup() {
  if (DEBUG) Serial.begin(9600);  // Only set up serial communication if debugging is enabled
  delay(2000);  //Wait to ensure LED panel powers up
  FastLED.addLeds<WS2812B, DATA_PIN, GRB>(leds, NUM_LEDS);    
  FastLED.setBrightness(INIT_BRIGHT); //Number 0-255, default to low power so we can run over usb for debugging
  FastLED.clear();  //Set LED array to zero
  
  //Set up digital inputs
  colorBtn.begin(COLOR_BUTTON);
  cubeBtn.begin(CUBE_BUTTON);
  coneBtn.begin(CONE_BUTTON);
  distanceBtn.begin(DISTANCE_BUTTON);
}
const String msg = " DATABITS 3883";  //Message starts with a space so it scrolls entirely from left to right

//Start at ascii 47 go through ascii 90 (upper case), 47 == blank character instead of '/'
const char UpperFont12x16Data[] PROGMEM = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	//  ASCII DEC - 47
			0x0F,0x80,0x3F,0xE0,0x30,0x60,0x60,0x70,0x60,0xF0,0x61,0xB0,0x63,0x30,0x66,0x30,0x6C,0x30,0x78,0x30,0x70,0x30,0x30,0x60,0x3F,0xE0,0x0F,0x80,0x00,0x00,0x00,0x00,	// 0
			0x03,0x00,0x07,0x00,0x1F,0x00,0x1F,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x1F,0xE0,0x1F,0xE0,0x00,0x00,0x00,0x00,	// 1
			0x1F,0xC0,0x3F,0xE0,0x70,0x70,0x60,0x30,0x60,0x70,0x00,0xE0,0x01,0xC0,0x03,0x80,0x07,0x00,0x0E,0x00,0x1C,0x00,0x38,0x00,0x7F,0xF0,0x7F,0xF0,0x00,0x00,0x00,0x00,	// 2
			0x1F,0xC0,0x3F,0xE0,0x70,0x70,0x60,0x30,0x00,0x30,0x00,0x70,0x0F,0xE0,0x0F,0xC0,0x00,0x60,0x00,0x30,0x60,0x30,0x70,0x70,0x3F,0xE0,0x1F,0xC0,0x00,0x00,0x00,0x00,	// 3
			0x01,0xC0,0x03,0xC0,0x07,0xC0,0x0E,0xC0,0x1C,0xC0,0x38,0xC0,0x70,0xC0,0x60,0xC0,0x7F,0xF0,0x7F,0xF0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x00,0x00,0x00,0x00,	// 4
			0x7F,0xF0,0x7F,0xF0,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0xC0,0x3F,0xE0,0x00,0x70,0x00,0x30,0x00,0x30,0x60,0x30,0x70,0x70,0x3F,0xE0,0x1F,0xC0,0x00,0x00,0x00,0x00,	// 5
			0x03,0xC0,0x07,0xC0,0x0E,0x00,0x1C,0x00,0x38,0x00,0x30,0x00,0x7F,0xC0,0x7F,0xE0,0x70,0x70,0x60,0x30,0x60,0x30,0x70,0x70,0x3F,0xE0,0x1F,0xC0,0x00,0x00,0x00,0x00,	// 6
			0x7F,0xF0,0x7F,0xF0,0x00,0x60,0x00,0x60,0x00,0xC0,0x00,0xC0,0x01,0x80,0x01,0x80,0x03,0x00,0x03,0x00,0x06,0x00,0x06,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,	// 7
			0x0F,0x80,0x1F,0xC0,0x38,0xE0,0x30,0x60,0x30,0x60,0x38,0xE0,0x1F,0xC0,0x3F,0xE0,0x70,0x70,0x60,0x30,0x60,0x30,0x70,0x70,0x3F,0xE0,0x1F,0xC0,0x00,0x00,0x00,0x00,	// 8
			0x1F,0xC0,0x3F,0xE0,0x70,0x70,0x60,0x30,0x60,0x30,0x70,0x70,0x3F,0xF0,0x1F,0xF0,0x00,0x60,0x00,0xE0,0x01,0xC0,0x03,0x80,0x1F,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,	// 9
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// :
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x06,0x00,0x06,0x00,0x0C,0x00,	// ;
			0x01,0x80,0x03,0xc0,0x03,0xc0,0x03,0xc0,0x07,0xe0,0x07,0xe0,0x07,0xe0,0x07,0xe0,0x0f,0xf0,0x0f,0xf0,0x0f,0xf0,0x1f,0xf8,0x1f,0xf8,0x1f,0xf8,0x7f,0xfe,0x7f,0xfe,	// < (cone)
			/*0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xE0,0x3F,0xE0,0x00,0x00,0x00,0x00,0x3F,0xE0,0x3F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// = */
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xE0,0x3F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	// = ( - )
			0x30,0x00,0x38,0x00,0x1C,0x00,0x0E,0x00,0x07,0x00,0x03,0x80,0x01,0xC0,0x01,0xC0,0x03,0x80,0x07,0x00,0x0E,0x00,0x1C,0x00,0x38,0x00,0x30,0x00,0x00,0x00,0x00,0x00,	// >
			0x1F,0x80,0x3F,0xC0,0x70,0xE0,0x60,0x60,0x60,0xE0,0x01,0xC0,0x03,0x80,0x07,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,	// ?
			0x00,0x00,0x07,0xff,0x08,0x03,0x10,0x05,0x20,0x09,0x7f,0xf1,0x7f,0xf1,0x7f,0xf1,0x7f,0xf1,0x7f,0xf1,0x7f,0xf1,0x7f,0xf1,0x7f,0xf2,0x7f,0xf4,0x7f,0xf8,0x7f,0xf0,	// @ (cube)
			0x06,0x00,0x06,0x00,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x19,0x80,0x19,0x80,0x19,0x80,0x30,0xC0,0x3F,0xC0,0x3F,0xC0,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,	// A
			0x7F,0x00,0x7F,0x80,0x61,0xC0,0x60,0xC0,0x60,0xC0,0x61,0xC0,0x7F,0x80,0x7F,0xC0,0x60,0xE0,0x60,0x60,0x60,0x60,0x60,0xE0,0x7F,0xC0,0x7F,0x80,0x00,0x00,0x00,0x00,	// B
			0x0F,0x80,0x1F,0xC0,0x38,0xE0,0x30,0x60,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x30,0x60,0x38,0xE0,0x1F,0xC0,0x0F,0x80,0x00,0x00,0x00,0x00,	// C
			0x7F,0x00,0x7F,0x80,0x61,0xC0,0x60,0xC0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xC0,0x61,0xC0,0x7F,0x80,0x7F,0x00,0x00,0x00,0x00,0x00,	// D
			0x7F,0xE0,0x7F,0xE0,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0x80,0x7F,0x80,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0xE0,0x7F,0xE0,0x00,0x00,0x00,0x00,	// E
			0x7F,0xE0,0x7F,0xE0,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0x80,0x7F,0x80,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,0x00,	// F
			0x0F,0xC0,0x1F,0xE0,0x38,0x60,0x30,0x00,0x60,0x00,0x60,0x00,0x63,0xE0,0x63,0xE0,0x60,0x60,0x60,0x60,0x30,0x60,0x38,0x60,0x1F,0xE0,0x0F,0xE0,0x00,0x00,0x00,0x00,	// G
			0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7F,0xE0,0x7F,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,	// H
			0x1F,0x80,0x1F,0x80,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x1F,0x80,0x1F,0x80,0x00,0x00,0x00,0x00,	// I
			0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x60,0x60,0x60,0x60,0x70,0xC0,0x3F,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,	// J
			0x60,0x60,0x60,0xE0,0x61,0xC0,0x63,0x80,0x67,0x00,0x6E,0x00,0x7C,0x00,0x7C,0x00,0x6E,0x00,0x67,0x00,0x63,0x80,0x61,0xC0,0x60,0xE0,0x60,0x60,0x00,0x00,0x00,0x00,	// K
			0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0xE0,0x7F,0xE0,0x00,0x00,0x00,0x00,	// L
			0x60,0x60,0x70,0xE0,0x70,0xE0,0x79,0xE0,0x79,0xE0,0x6F,0x60,0x6F,0x60,0x66,0x60,0x66,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,	// M
			0x60,0x60,0x70,0x60,0x70,0x60,0x78,0x60,0x6C,0x60,0x6C,0x60,0x66,0x60,0x66,0x60,0x63,0x60,0x63,0x60,0x61,0xE0,0x60,0xE0,0x60,0xE0,0x60,0x60,0x00,0x00,0x00,0x00,	// N
			0x0F,0x00,0x1F,0x80,0x39,0xC0,0x30,0xC0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x30,0xC0,0x39,0xC0,0x1F,0x80,0x0F,0x00,0x00,0x00,0x00,0x00,	// O
			0x7F,0x80,0x7F,0xC0,0x60,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xE0,0x7F,0xC0,0x7F,0x80,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,0x00,	// P
			0x0F,0x00,0x1F,0x80,0x39,0xC0,0x30,0xC0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x63,0x60,0x33,0xC0,0x39,0xC0,0x1F,0xE0,0x0F,0x60,0x00,0x00,0x00,0x00,	// Q
			0x7F,0x80,0x7F,0xC0,0x60,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xE0,0x7F,0xC0,0x7F,0x80,0x67,0x00,0x63,0x80,0x61,0xC0,0x60,0xE0,0x60,0x60,0x00,0x00,0x00,0x00,	// R
			0x1F,0x80,0x3F,0xC0,0x70,0xE0,0x60,0x60,0x60,0x00,0x70,0x00,0x3F,0x80,0x1F,0xC0,0x00,0xE0,0x00,0x60,0x60,0x60,0x70,0xE0,0x3F,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,	// S
			0x3F,0xC0,0x3F,0xC0,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,	// T
			0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x30,0xC0,0x3F,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,	// U
			0x60,0x60,0x60,0x60,0x60,0x60,0x30,0xC0,0x30,0xC0,0x30,0xC0,0x19,0x80,0x19,0x80,0x19,0x80,0x0F,0x00,0x0F,0x00,0x0F,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,	// V
			0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x66,0x60,0x66,0x60,0x6F,0x60,0x79,0xE0,0x70,0xE0,0x70,0xE0,0x60,0x60,0x00,0x00,0x00,0x00,	// W
			0x60,0x60,0x60,0x60,0x30,0xC0,0x30,0xC0,0x19,0x80,0x0F,0x00,0x06,0x00,0x06,0x00,0x0F,0x00,0x19,0x80,0x30,0xC0,0x30,0xC0,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,	// X
			0x60,0x60,0x60,0x60,0x30,0xC0,0x30,0xC0,0x19,0x80,0x19,0x80,0x0F,0x00,0x0F,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,	// Y
			0x7F,0xE0,0x7F,0xE0,0x00,0xC0,0x00,0xC0,0x01,0x80,0x03,0x00,0x06,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x30,0x00,0x30,0x00,0x7F,0xE0,0x7F,0xE0,0x00,0x00,0x00,0x00,	// Z - ASCII DEC 90
			};

//Set default color to green
uint32_t currentColor = CRGB::Green;
boolean isDisplayCube = false;
boolean isDisplayCone = false;
boolean isDistanceMode = false;

int getIndexForChar(char aChar)
{
  int asciiChar = (int)aChar;
  if ((asciiChar < MIN_ASCII) || (asciiChar > MAX_ASCII)) asciiChar = MIN_ASCII;
  return ((asciiChar - MIN_ASCII) * (CHAR_WIDTH * 2));
}

/**
  * Poll the digital button IOs, debouncing the results to remove noise
  */
void checkButtons()
{
  //Check for color button
  if (colorBtn.debounce()) 
  {
    changeColor();
  }
  if (cubeBtn.debounce()) 
  {
    isDisplayCube=!isDisplayCube;
  }
  if (coneBtn.debounce()) 
  {
    isDisplayCone=!isDisplayCone;
  }
  if (distanceBtn.debounce()) 
  {
    //Toggle Distance display
    isDistanceMode=!isDistanceMode;
  }  
}

/**
  * If the color change button is selected, loop through color selections
  * This also checks the brightness setting, to limit analog reads
  */
void changeColor()
{
  if (currentColor == CRGB::Green)
  {
    if (DEBUG) Serial.println("color button pressed setting color to red"); 
    currentColor = CRGB::Red;
  }
  else if (currentColor == CRGB::Red)
  {
    if (DEBUG) Serial.println("color button pressed setting color to blue"); 
    currentColor = CRGB::Blue;      
  }
  else
  {
    if (DEBUG) Serial.println("color button pressed setting color to green"); 
    currentColor = CRGB::Green;
  }

  //Also check analog potential value only during change color routine, returns 0 - 1024
  int potVal = analogRead(POT_PIN);  
  if (potVal > INIT_BRIGHT) 
  {
    FastLED.setBrightness(potVal/4); //Number 0-255
  }
}

/**
 *  Main code, loop forever
 */
void loop() 
{
  //Loop through the message array
  for (int msgLetter = 0; msgLetter < msg.length(); msgLetter++)
  {
    //Get the next 3 characters as we can show up to 3 parts of characters on the screen at once
    char aChar = msg[msgLetter];    
    int bCharPos = (msgLetter+1);
    if (bCharPos > msg.length()) bCharPos -= msg.length(); //If we reached the end of the char array, loop to beginning
    char bChar = msg[bCharPos];
    int cCharPos = (msgLetter+2);
    if (cCharPos > msg.length()) cCharPos -= msg.length(); //If we reached the end of the char array, loop to beginning
    char cChar = msg[cCharPos];
    if (DEBUG) Serial.println(aChar);  //output the first character in the message
    
    //scroll each pixel of current character from right to left, 0 is full character, 15 is one row shown
    for (int scrollX = (CHAR_WIDTH-1); scrollX >= 3; scrollX--)
    {           
      //poll the buttons, this occurs about every 100 ms
      checkButtons();

      //Check for cone/cube display
      if (isDisplayCone)
      {
        //Display the cone symbol from right to left, takes 1.6 seconds.
        if (DEBUG) Serial.println("display cone!");
        FastLED.clear();
        displayChar('<',  0, CRGB::Yellow); //Cone Character will replace < in array
        FastLED.show();
        for (int timeLoop=0; timeLoop < CONE_CUBE_DISPLAY_TIME; timeLoop+=100)
        {
          delay(100);
        }
        isDisplayCone = false;
      }
      if (isDisplayCube)
      {
        //Display the cube symbol from right to left, takes 1.6 seconds.
        if (DEBUG) Serial.println("display cube!");
        FastLED.clear();
        displayChar('@',  0, CRGB::Purple); //Cube Character will replace @ in array
        FastLED.show();
        for (int timeLoop=0; timeLoop < CONE_CUBE_DISPLAY_TIME; timeLoop+=100)
        {
          delay(100);
        }
        isDisplayCube = false;
      }
      if (isDistanceMode)
      {
        //int inches = sonar.ping_in();
        int inches = sonar.convert_in(sonar.ping_median(5));
        FastLED.clear();
        if (DEBUG) { Serial.print("sonar read in inches: ");  Serial.println(inches); }

        uint32_t distanceColor = CRGB::Red;
        //Allow 20 inches on either side
        if ((inches > (TARGET_DISTANCE-20)) && (inches < TARGET_DISTANCE+20))
        {
          boolean negative = false;
          int deltaInches = (inches - TARGET_DISTANCE)/2;  //Divide by 2
          if (deltaInches < 0)
          {
            negative = true;
            deltaInches = abs(deltaInches); /* lose sign */
          }
          if (deltaInches > 2) distanceColor = CRGB::Yellow;
          if (deltaInches > 6) distanceColor = CRGB::Green;
          if (negative) displayChar('=',  -6, distanceColor);
          //Add 48 to the number to get 0-9 characters
          displayChar((char)(deltaInches+48), 5, distanceColor);
        }
        else
        {
          //Fill completely green (too far or too close)
          for (int jj=0; jj < NUM_LEDS; jj++) leds[jj] = CRGB::Green;
        }
        FastLED.show();
        delay(100);
      }
      else
      {
        //Nothing else to do, so continue looping the message
        FastLED.clear(); //clear out the LED array in memory

        //Get the positions of the next 3 characters as we can show up to 3 parts of characters on the screen at once
        int charApos = scrollX - 15;
        int charBpos = (scrollX -15) + CHAR_REAL_WIDTH; 
        int charCpos = (scrollX -15) + (CHAR_REAL_WIDTH*2); 
        //Based on loop, determine which characters are displayed at what locations
        if (charApos >= -15)
        {          
          displayChar(aChar, charApos, currentColor); //display First Character
        }
        if ((charBpos <= 15) && (charBpos >= -15))
        {
          displayChar(bChar,  charBpos, currentColor); //Display second character
        }
        if (charCpos <= 15)
        {          
          displayChar(cChar,  charCpos, currentColor); //Display Third character
        }
        FastLED.show();  //Show the LED screen

        //if (DEBUG) Serial.println(scrollX);
        delay(100);
      } //End if scroll message
    }//end for windowX
  } // end for msgLetter
} //End Loop

/*
 * This displays a single character in a single color at a specified offset
 * Offset of 0 means character fully on display, 
 * -8 is right half showing, 
 * 8 left half showing, etc
*/
void displayChar(char aChar, int offset, uint32_t colorCode)
{ 
  //sanity check
  if ((offset < -15) || (offset > 15)) offset = 0;
  //int readCharLocation = getIndexForChar(aChar);
  int startA = getIndexForChar(aChar);
  int startB = startA;
  int scrollX = 15;
  //Optimize the start and end of the X loop to only the zones the character needs to be in
  int pixelXend = 16;
  int pixelXstart = 0;
  if (offset < 0) 
  {
    //add the negative offset to scrollX, set charB to zero
    scrollX += offset;
    startB=0;
    //Add the offset to the "right" side of the LED for starting zone
    pixelXstart += offset;
  }
  if (offset > 0)
  {
    //Set scrollX one less than offset, set CharA to zero
    scrollX = offset-1;
    startA = 0;
    pixelXend = 16 - offset;
  }
  
  for (int pixelY = 0; pixelY < 16; pixelY++)
  {
    int charY = pixelY*2;
    int pixelYLEDLoc = pixelY*16;

    for (int pixelX = pixelXstart; pixelX < pixelXend; pixelX++)
    {
      //Invert from 15 -> 0 for the inverted rows, and also use this for outputing the Char Matrix
      int inverse = 15 - pixelX;
      int pixelXAdjusted = pixelX;
      //The LED wraps LtoR on even (0,2) rows, RtoL odd (1,3) rows
      if (pixelY % 2) pixelXAdjusted = inverse;

      //Get the X,Y values used for the letter matrix, 2 bytes per row, 16 rows per character
      //int charY = pixelY*2; //moved to inside Y loop
      int charX = 0;  
      int readCharLocation = startB;
      int charXOffset = pixelX + scrollX;
      if (charXOffset > (CHAR_WIDTH-1)) 
      {
        charXOffset = charXOffset - CHAR_WIDTH;
        readCharLocation = startA; //switch to next letter
      }
      int charInverse = (15) - (charXOffset);
      if (charInverse > (7)) charX++;
      int mod = charXOffset % 8; //get the bit 0-7 to read
      readCharLocation += charY+charX;

      char readChar = pgm_read_byte(&(UpperFont12x16Data[readCharLocation]));
      //Quick skip for 0
      if ((readChar != 0) && (bitRead(readChar,mod)))
        leds[(pixelYLEDLoc)+pixelXAdjusted] = colorCode;
    }  //end for pixelX
  }  //end for pixelY
}


